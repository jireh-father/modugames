<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ëª¨ì°Œë“œë¡­ (Mochi Drop)</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #fce4ec;
  overflow: hidden;
  touch-action: none;
  font-family: 'Segoe UI', sans-serif;
  user-select: none;
}
canvas { display: block; }
#ui {
  position: fixed; top: 0; left: 0; right: 0;
  display: flex; justify-content: space-between; align-items: center;
  padding: 12px 16px; pointer-events: none; z-index: 10;
}
#ui > div {
  background: rgba(255,255,255,0.85); padding: 8px 16px;
  border-radius: 20px; font-size: 15px; color: #c62828; font-weight: bold;
}
#nextPreview {
  position: fixed; top: 60px; right: 16px;
  background: rgba(255,255,255,0.85); padding: 10px 16px;
  border-radius: 16px; text-align: center; font-size: 13px; color: #e91e63;
  z-index: 10;
}
#nextPreview canvas { margin-top: 6px; }
#startScreen {
  position: fixed; inset: 0;
  background: linear-gradient(180deg, #fce4ec 0%, #f8bbd0 50%, #fce4ec 100%);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  color: #c62828; z-index: 100;
}
#startScreen h1 { font-size: 48px; margin-bottom: 8px; }
#startScreen p { color: #e91e63; margin-bottom: 30px; font-size: 16px; text-align: center; line-height: 1.6; }
#startScreen button {
  background: linear-gradient(135deg, #e91e63, #f06292);
  color: #fff; border: none; padding: 16px 48px; border-radius: 30px;
  font-size: 20px; cursor: pointer; font-weight: bold;
  box-shadow: 0 4px 20px rgba(233,30,99,0.4);
}
#gameOver {
  position: fixed; inset: 0; background: rgba(252,228,236,0.95);
  display: none; flex-direction: column; align-items: center; justify-content: center;
  color: #c62828; z-index: 100;
}
#gameOver h2 { font-size: 36px; margin-bottom: 16px; }
#gameOver .final-score { font-size: 48px; color: #e91e63; font-weight: bold; margin-bottom: 8px; }
#gameOver .best { font-size: 18px; color: #f06292; margin-bottom: 24px; }
#gameOver button {
  background: linear-gradient(135deg, #e91e63, #f06292);
  color: #fff; border: none; padding: 14px 40px; border-radius: 30px;
  font-size: 18px; cursor: pointer; font-weight: bold;
  box-shadow: 0 4px 20px rgba(233,30,99,0.4);
}
</style>
</head>
<body>
<div id="startScreen">
  <h1>ëª¨ì°Œë“œë¡­</h1>
  <p>ëª¨ì°Œë¥¼ ë–¨ì–´ëœ¨ë ¤ ê°™ì€ ìƒ‰ë¼ë¦¬ í•©ì¹˜ì„¸ìš”!<br>í•©ì¹ ìˆ˜ë¡ ì»¤ì ¸ìš” ğŸ¡</p>
  <button onclick="startGame()">ì‹œì‘í•˜ê¸°</button>
</div>
<div id="ui">
  <div id="scoreDisplay">ì ìˆ˜: 0</div>
  <div id="bestDisplay">ìµœê³ : 0</div>
</div>
<div id="nextPreview">ë‹¤ìŒ</div>
<div id="gameOver">
  <h2>ê²Œì„ ì˜¤ë²„!</h2>
  <div class="final-score" id="finalScore">0</div>
  <div class="best" id="bestScore">ìµœê³  ê¸°ë¡: 0</div>
  <button onclick="startGame()">ë‹¤ì‹œ í•˜ê¸°</button>
</div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Audio
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(freq, dur, type = 'sine', vol = 0.12) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  osc.connect(gain); gain.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + dur);
}
function playDrop() { playSound(200, 0.15, 'sine', 0.08); }
function playBounce() { playSound(150, 0.08, 'sine', 0.05); }
function playMerge(tier) {
  const base = 300 + tier * 80;
  playSound(base, 0.4, 'sine', 0.15);
  playSound(base * 1.25, 0.3, 'sine', 0.08);
}

// Mochi tiers (color, size, name)
const MOCHI_TIERS = [
  { color: '#f48fb1', face: 'â—•â€¿â—•', radius: 18, name: 'ë”¸ê¸°ëª¨ì°Œ', points: 10 },
  { color: '#ce93d8', face: 'â—â€¿â—', radius: 24, name: 'í¬ë„ëª¨ì°Œ', points: 20 },
  { color: '#90caf9', face: 'â—•Ï‰â—•', radius: 30, name: 'ë¸”ë£¨ëª¨ì°Œ', points: 40 },
  { color: '#a5d6a7', face: 'â— â€¿â— ', radius: 36, name: 'ë§ì°¨ëª¨ì°Œ', points: 80 },
  { color: '#fff176', face: 'â—•â—¡â—•', radius: 42, name: 'ë ˆëª¬ëª¨ì°Œ', points: 160 },
  { color: '#ffab91', face: 'â—‰â€¿â—‰', radius: 50, name: 'ê·¤ëª¨ì°Œ', points: 320 },
  { color: '#ef5350', face: 'â˜…â€¿â˜…', radius: 58, name: 'ë©”ê°€ëª¨ì°Œ', points: 640 },
];
const MAX_DROP_TIER = 3; // only drop small ones

// Container
const CONTAINER_MARGIN = 30;
const CONTAINER_TOP = 180;
let CL, CR, CB; // container left, right, bottom

function updateContainer() {
  const containerWidth = Math.min(W - CONTAINER_MARGIN * 2, 380);
  CL = (W - containerWidth) / 2;
  CR = CL + containerWidth;
  CB = H - 40;
}

// Physics
const GRAVITY = 0.35;
const BOUNCE = 0.35;
const DAMPING = 0.98;

let mochis = [];
let particles = [];
let currentTier = 0;
let nextTier = 0;
let dropX = 0;
let score = 0;
let bestScore = parseInt(localStorage.getItem('mochiDropBest') || '0');
let gameActive = false;
let canDrop = true;
let dropCooldown = 0;
let gameOverTimer = 0;
let isDragging = false;

function randomDropTier() {
  return Math.floor(Math.random() * MAX_DROP_TIER);
}

function init() {
  updateContainer();
  mochis = [];
  particles = [];
  score = 0;
  currentTier = randomDropTier();
  nextTier = randomDropTier();
  dropX = W / 2;
  canDrop = true;
  dropCooldown = 0;
  gameOverTimer = 0;
  updateUI();
}

function updateUI() {
  document.getElementById('scoreDisplay').textContent = `ì ìˆ˜: ${score}`;
  document.getElementById('bestDisplay').textContent = `ìµœê³ : ${bestScore}`;
}

// Drop mochi
function drop() {
  if (!canDrop || !gameActive) return;
  canDrop = false;
  dropCooldown = 30;

  const tier = MOCHI_TIERS[currentTier];
  mochis.push({
    x: dropX,
    y: CONTAINER_TOP - 20,
    vx: 0,
    vy: 0,
    tier: currentTier,
    radius: tier.radius,
    squishX: 1,
    squishY: 1,
    settled: false,
  });

  playDrop();
  currentTier = nextTier;
  nextTier = randomDropTier();
}

// Input
canvas.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  if (!gameActive) return;
  isDragging = true;
  dropX = Math.max(CL + 25, Math.min(CR - 25, e.clientX));
});
canvas.addEventListener('pointermove', (e) => {
  e.preventDefault();
  if (isDragging) {
    dropX = Math.max(CL + 25, Math.min(CR - 25, e.clientX));
  }
});
canvas.addEventListener('pointerup', (e) => {
  e.preventDefault();
  if (isDragging && gameActive) {
    drop();
  }
  isDragging = false;
});

function update() {
  if (!gameActive) return;

  // Drop cooldown
  if (!canDrop) {
    dropCooldown--;
    if (dropCooldown <= 0) canDrop = true;
  }

  // Physics for each mochi
  for (const m of mochis) {
    // Gravity
    m.vy += GRAVITY;

    // Apply velocity
    m.x += m.vx;
    m.y += m.vy;

    // Damping
    m.vx *= DAMPING;

    // Container walls
    if (m.x - m.radius < CL) {
      m.x = CL + m.radius;
      m.vx = Math.abs(m.vx) * BOUNCE;
      m.squishX = 0.85;
      playBounce();
    }
    if (m.x + m.radius > CR) {
      m.x = CR - m.radius;
      m.vx = -Math.abs(m.vx) * BOUNCE;
      m.squishX = 0.85;
      playBounce();
    }
    // Floor
    if (m.y + m.radius > CB) {
      m.y = CB - m.radius;
      m.vy = -Math.abs(m.vy) * BOUNCE;
      if (Math.abs(m.vy) < 1) m.vy = 0;
      m.squishY = 0.85;
      m.squishX = 1.15;
      playBounce();
    }

    // Squish recovery
    m.squishX += (1 - m.squishX) * 0.1;
    m.squishY += (1 - m.squishY) * 0.1;
  }

  // Mochi-mochi collision
  for (let i = 0; i < mochis.length; i++) {
    for (let j = i + 1; j < mochis.length; j++) {
      const a = mochis[i];
      const b = mochis[j];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = a.radius + b.radius;

      if (dist < minDist && dist > 0) {
        // Separate
        const overlap = minDist - dist;
        const nx = dx / dist;
        const ny = dy / dist;

        a.x -= nx * overlap * 0.5;
        a.y -= ny * overlap * 0.5;
        b.x += nx * overlap * 0.5;
        b.y += ny * overlap * 0.5;

        // Velocity exchange
        const relVx = a.vx - b.vx;
        const relVy = a.vy - b.vy;
        const dotN = relVx * nx + relVy * ny;

        if (dotN > 0) {
          a.vx -= dotN * nx * 0.5;
          a.vy -= dotN * ny * 0.5;
          b.vx += dotN * nx * 0.5;
          b.vy += dotN * ny * 0.5;
        }

        // Squish
        const squishAmt = Math.min(0.15, overlap * 0.01);
        a.squishX = 1 + squishAmt;
        a.squishY = 1 - squishAmt;
        b.squishX = 1 + squishAmt;
        b.squishY = 1 - squishAmt;
      }
    }
  }

  // Check merges (same tier touching)
  let merged = false;
  for (let i = mochis.length - 1; i >= 0; i--) {
    for (let j = i - 1; j >= 0; j--) {
      if (i >= mochis.length) break;
      const a = mochis[i];
      const b = mochis[j];
      if (a.tier !== b.tier) continue;
      if (a.tier >= MOCHI_TIERS.length - 1) continue;

      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < a.radius + b.radius * 0.8) {
        // Merge!
        const newTier = a.tier + 1;
        const newMochi = MOCHI_TIERS[newTier];
        const mx = (a.x + b.x) / 2;
        const my = (a.y + b.y) / 2;

        score += newMochi.points;

        // Particles
        for (let p = 0; p < 12; p++) {
          const angle = (Math.PI * 2 / 12) * p;
          const speed = 2 + Math.random() * 3;
          particles.push({
            x: mx, y: my,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 2,
            life: 1,
            color: MOCHI_TIERS[a.tier].color,
            size: 5 + Math.random() * 4,
          });
        }
        // Score popup
        particles.push({
          x: mx, y: my - 30,
          vx: 0, vy: -1.5,
          life: 1.5, isText: true,
          text: `+${newMochi.points}`,
          color: '#c62828',
        });

        // Remove old, add new
        mochis.splice(i, 1);
        mochis.splice(j, 1);
        mochis.push({
          x: mx, y: my,
          vx: 0, vy: -1,
          tier: newTier,
          radius: newMochi.radius,
          squishX: 1.3,
          squishY: 0.7,
          settled: false,
        });

        playMerge(newTier);
        merged = true;
        updateUI();
        break;
      }
    }
    if (merged) break;
  }

  // Game over check: any mochi above container top for too long
  const anyAbove = mochis.some(m => m.y - m.radius < CONTAINER_TOP && m.vy <= 0.5);
  if (anyAbove && mochis.length > 1) {
    gameOverTimer++;
    if (gameOverTimer > 120) {
      gameActive = false;
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('mochiDropBest', bestScore.toString());
      }
      document.getElementById('finalScore').textContent = score;
      document.getElementById('bestScore').textContent = `ìµœê³  ê¸°ë¡: ${bestScore}`;
      document.getElementById('gameOver').style.display = 'flex';
      playSound(200, 0.5, 'sawtooth', 0.1);
    }
  } else {
    gameOverTimer = 0;
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    if (!p.isText) p.vy += 0.05;
    p.life -= 0.02;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawMochi(m) {
  const tier = MOCHI_TIERS[m.tier];
  const r = m.radius;

  ctx.save();
  ctx.translate(m.x, m.y);
  ctx.scale(m.squishX, m.squishY);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  ctx.beginPath();
  ctx.ellipse(2, r * 0.15, r * 0.9, r * 0.3, 0, 0, Math.PI * 2);
  ctx.fill();

  // Body
  const bodyGrad = ctx.createRadialGradient(-r * 0.2, -r * 0.2, r * 0.1, 0, 0, r);
  bodyGrad.addColorStop(0, '#fff');
  bodyGrad.addColorStop(0.4, tier.color);
  bodyGrad.addColorStop(1, tier.color);
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();

  // Outline
  ctx.strokeStyle = 'rgba(0,0,0,0.1)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Face
  ctx.fillStyle = '#5d4037';
  const eyeY = -r * 0.15;
  const eyeSpacing = r * 0.25;
  const eyeSize = Math.max(2, r * 0.08);

  // Eyes
  ctx.beginPath();
  ctx.arc(-eyeSpacing, eyeY, eyeSize, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(eyeSpacing, eyeY, eyeSize, 0, Math.PI * 2);
  ctx.fill();

  // Eye highlights
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-eyeSpacing + 1, eyeY - 1, eyeSize * 0.4, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(eyeSpacing + 1, eyeY - 1, eyeSize * 0.4, 0, Math.PI * 2);
  ctx.fill();

  // Mouth
  ctx.strokeStyle = '#5d4037';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(0, eyeY + r * 0.2, r * 0.15, 0.1 * Math.PI, 0.9 * Math.PI);
  ctx.stroke();

  // Cheeks (blush)
  ctx.fillStyle = 'rgba(255,100,100,0.2)';
  ctx.beginPath();
  ctx.ellipse(-eyeSpacing - r * 0.1, eyeY + r * 0.2, r * 0.12, r * 0.08, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(eyeSpacing + r * 0.1, eyeY + r * 0.2, r * 0.12, r * 0.08, 0, 0, Math.PI * 2);
  ctx.fill();

  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.beginPath();
  ctx.ellipse(-r * 0.25, -r * 0.35, r * 0.2, r * 0.15, -0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function draw() {
  // Background
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, '#fce4ec');
  bg.addColorStop(1, '#f8bbd0');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  updateContainer();

  // Container
  ctx.strokeStyle = '#e91e63';
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';

  // Left wall
  ctx.beginPath();
  ctx.moveTo(CL, CONTAINER_TOP);
  ctx.lineTo(CL, CB);
  ctx.stroke();

  // Bottom
  ctx.beginPath();
  ctx.moveTo(CL, CB);
  ctx.lineTo(CR, CB);
  ctx.stroke();

  // Right wall
  ctx.beginPath();
  ctx.moveTo(CR, CONTAINER_TOP);
  ctx.lineTo(CR, CB);
  ctx.stroke();

  // Container fill
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillRect(CL + 2, CONTAINER_TOP, CR - CL - 4, CB - CONTAINER_TOP - 2);

  // Danger line
  ctx.strokeStyle = 'rgba(233,30,99,0.3)';
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 8]);
  ctx.beginPath();
  ctx.moveTo(CL + 5, CONTAINER_TOP);
  ctx.lineTo(CR - 5, CONTAINER_TOP);
  ctx.stroke();
  ctx.setLineDash([]);

  // Drop guide
  if (canDrop && gameActive) {
    ctx.strokeStyle = 'rgba(233,30,99,0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(dropX, CONTAINER_TOP - 50);
    ctx.lineTo(dropX, CB);
    ctx.stroke();
    ctx.setLineDash([]);

    // Preview mochi at top
    const previewMochi = {
      x: dropX,
      y: CONTAINER_TOP - 50,
      tier: currentTier,
      radius: MOCHI_TIERS[currentTier].radius,
      squishX: 1,
      squishY: 1,
    };
    ctx.globalAlpha = 0.7;
    drawMochi(previewMochi);
    ctx.globalAlpha = 1;
  }

  // Draw mochis (sort by y for depth)
  const sorted = [...mochis].sort((a, b) => a.y - b.y);
  for (const m of sorted) {
    drawMochi(m);
  }

  // Next preview
  const nextEl = document.getElementById('nextPreview');
  const nextMochi = MOCHI_TIERS[nextTier];
  nextEl.innerHTML = `ë‹¤ìŒ<br><span style="font-size:24px;color:${nextMochi.color}">â—</span><br><span style="font-size:11px">${nextMochi.name}</span>`;

  // Particles
  for (const p of particles) {
    if (p.isText) {
      ctx.fillStyle = p.color || '#c62828';
      ctx.globalAlpha = Math.min(1, p.life);
      ctx.font = 'bold 20px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(p.text, p.x, p.y);
      ctx.globalAlpha = 1;
    } else {
      ctx.fillStyle = p.color;
      ctx.globalAlpha = Math.min(1, p.life);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Game over warning flash
  if (gameOverTimer > 0 && gameActive) {
    ctx.fillStyle = `rgba(233,30,99,${0.1 + Math.sin(gameOverTimer * 0.2) * 0.1})`;
    ctx.fillRect(0, 0, W, H);
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

function startGame() {
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameOver').style.display = 'none';
  init();
  gameActive = true;
}

gameLoop();
</script>
</body>
</html>
