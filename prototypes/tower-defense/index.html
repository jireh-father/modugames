<!DOCTYPE html>
<html><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>ÌÉÄÏõå ÎîîÌéúÏä§</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;display:flex;justify-content:center;align-items:center;height:100vh;overflow:hidden;touch-action:none}
canvas{background:#2d5a1e;max-width:100vw;max-height:100vh;object-fit:contain}
</style>
</head><body>
<canvas id="c" width="540" height="960"></canvas>
<script>
const W=540,H=960,c=document.getElementById('c'),ctx=c.getContext('2d');
function resize(){const s=Math.min(innerWidth/W,innerHeight/H);c.style.width=W*s+'px';c.style.height=H*s+'px'}
resize();addEventListener('resize',resize);

const COLS=12,ROWS=14,TILE=40,MAP_X=(W-COLS*TILE)/2,MAP_Y=60;
const PANEL_Y=MAP_Y+ROWS*TILE+10;

// Path waypoints (grid coords)
const PATH=[
  {c:0,r:1},{c:10,r:1},{c:10,r:3},{c:1,r:3},{c:1,r:5},{c:10,r:5},
  {c:10,r:7},{c:1,r:7},{c:1,r:9},{c:10,r:9},{c:10,r:11},{c:1,r:11},{c:1,r:13},{c:11,r:13}
];
// Build path tiles
let pathTiles=new Set();
function buildPath(){
  for(let i=0;i<PATH.length-1;i++){
    let a=PATH[i],b=PATH[i+1];
    if(a.r===b.r){let minC=Math.min(a.c,b.c),maxC=Math.max(a.c,b.c);for(let cc=minC;cc<=maxC;cc++)pathTiles.add(a.r*COLS+cc)}
    else{let minR=Math.min(a.r,b.r),maxR=Math.max(a.r,b.r);for(let rr=minR;rr<=maxR;rr++)pathTiles.add(rr*COLS+a.c)}
  }
}
buildPath();

// Path points (pixel coords for enemies to follow)
let pathPoints=[];
function buildPathPoints(){
  for(let i=0;i<PATH.length;i++){
    pathPoints.push({x:MAP_X+PATH[i].c*TILE+TILE/2,y:MAP_Y+PATH[i].r*TILE+TILE/2});
  }
}
buildPathPoints();

const TOWER_TYPES=[
  {name:'ÌôîÏÇ¥',cost:50,color:'#2e8b57',range:120,dmg:8,rate:0.8,type:'arrow'},
  {name:'Ï∫êÎÖº',cost:100,color:'#d2691e',range:100,dmg:25,rate:1.5,type:'splash'},
  {name:'ÏñºÏùå',cost:75,color:'#4fc3f7',range:110,dmg:5,rate:1.0,type:'slow'},
  {name:'Î≤àÍ∞ú',cost:150,color:'#9c27b0',range:130,dmg:15,rate:1.2,type:'chain'},
  {name:'ÎèÖ',cost:120,color:'#4caf50',range:100,dmg:3,rate:1.0,type:'poison'}
];

const ENEMY_TYPES=[
  {name:'Ïä¨ÎùºÏûÑ',color:'#4caf50',hp:40,spd:50,r:8,gold:5},
  {name:'Í≥†Î∏îÎ¶∞',color:'#ff9800',hp:60,spd:70,r:9,gold:8},
  {name:'Ïò§ÌÅ¨',color:'#795548',hp:150,spd:35,r:12,gold:15},
  {name:'ÎèÑÏ†Å',color:'#607d8b',hp:30,spd:100,r:7,gold:10},
  {name:'Í≥®Î†ò',color:'#9e9e9e',hp:300,spd:25,r:14,gold:25},
  {name:'ÎìúÎûòÍ≥§',color:'#f44336',hp:800,spd:40,r:16,gold:50}
];

let state='menu',gold=200,lives=20,score=0,wave=0,maxWave=30;
let towers=[],enemies=[],projectiles=[],particles=[];
let selectedTower=null,autoWave=false,waveActive=false,spawnQueue=[];

function initGame(){
  gold=200;lives=20;score=0;wave=0;
  towers=[];enemies=[];projectiles=[];particles=[];
  selectedTower=null;autoWave=false;waveActive=false;spawnQueue=[];
}

function startWave(){
  if(waveActive||wave>=maxWave)return;
  wave++;waveActive=true;
  let count=5+wave*2;
  let isBoss=wave%5===0;
  spawnQueue=[];
  for(let i=0;i<count;i++){
    let ti=Math.min(5,Math.floor(wave/5));
    if(i===0&&isBoss)ti=5; // dragon boss
    else ti=Math.floor(Math.random()*Math.min(ti+1,5));
    let t=ENEMY_TYPES[ti];
    let hpMul=isBoss&&i===0?3:1+wave*0.1;
    spawnQueue.push({type:ti,hp:t.hp*hpMul,maxHp:t.hp*hpMul,spd:t.spd,r:t.r*(isBoss&&i===0?1.5:1),
      color:t.color,gold:t.gold,delay:i*0.6,pathIdx:0,x:pathPoints[0].x,y:pathPoints[0].y,
      slow:0,poison:0,alive:true,spawned:false});
  }
}

function getCanvasPos(e){
  let r=c.getBoundingClientRect();
  let t=e.touches?e.touches[0]:e;
  return{x:(t.clientX-r.left)/r.width*W,y:(t.clientY-r.top)/r.height*H};
}

function getGridCell(px,py){
  let col=Math.floor((px-MAP_X)/TILE),row=Math.floor((py-MAP_Y)/TILE);
  if(col>=0&&col<COLS&&row>=0&&row<ROWS)return{col,row};
  return null;
}

// Input
c.addEventListener('mousedown',e=>handleClick(getCanvasPos(e)));
c.addEventListener('touchstart',e=>{e.preventDefault();handleClick(getCanvasPos(e))});

function handleClick(p){
  if(state==='menu'){initGame();state='playing';return}
  if(state==='gameover'||state==='victory'){state='menu';return}

  // Tower panel selection
  if(p.y>PANEL_Y){
    let idx=Math.floor((p.x-10)/105);
    if(idx>=0&&idx<5){selectedTower=idx;return}
    // Next wave button
    if(p.x>W-120&&p.y>PANEL_Y+60){
      if(!waveActive)startWave();
      return;
    }
    // Auto toggle
    if(p.x>W-120&&p.y>PANEL_Y+30&&p.y<PANEL_Y+60){
      autoWave=!autoWave;return;
    }
    return;
  }

  // Place tower on grid
  let cell=getGridCell(p.x,p.y);
  if(cell&&selectedTower!==null){
    let key=cell.row*COLS+cell.col;
    if(pathTiles.has(key))return; // can't place on path
    if(towers.find(t=>t.col===cell.col&&t.row===cell.row))return; // occupied
    let td=TOWER_TYPES[selectedTower];
    if(gold<td.cost)return;
    gold-=td.cost;
    towers.push({col:cell.col,row:cell.row,type:selectedTower,level:1,
      x:MAP_X+cell.col*TILE+TILE/2,y:MAP_Y+cell.row*TILE+TILE/2,
      timer:0,dmg:td.dmg,range:td.range,rate:td.rate});
  }
}

// Update
let lastTime=0,spawnTime=0;
function update(time){
  requestAnimationFrame(update);
  let dt=Math.min((time-lastTime)/1000,0.05);lastTime=time;

  if(state!=='playing'){draw();return}

  // Spawn from queue
  if(waveActive){
    spawnTime+=dt;
    for(let s of spawnQueue){
      if(!s.spawned&&spawnTime>=s.delay){s.spawned=true;enemies.push(s)}
    }
    if(spawnQueue.every(s=>s.spawned)&&enemies.every(e=>!e.alive)){
      waveActive=false;spawnTime=0;
      if(wave>=maxWave){state='victory'}
      else if(autoWave)startWave();
    }
  }

  // Move enemies along path
  for(let e of enemies){
    if(!e.alive||!e.spawned)continue;
    let target=pathPoints[e.pathIdx+1];
    if(!target){e.alive=false;lives--;if(lives<=0)state='gameover';continue}
    let dx=target.x-e.x,dy=target.y-e.y,dist=Math.hypot(dx,dy);
    let spd=e.spd*(e.slow>0?0.5:1);
    if(dist<spd*dt){e.x=target.x;e.y=target.y;e.pathIdx++}
    else{e.x+=dx/dist*spd*dt;e.y+=dy/dist*spd*dt}
    if(e.slow>0)e.slow-=dt;
    if(e.poison>0){e.poison-=dt;e.hp-=10*dt}
    if(e.hp<=0){e.alive=false;gold+=e.gold;score+=e.gold}
  }
  enemies=enemies.filter(e=>e.alive||!e.spawned);

  // Towers shoot
  for(let t of towers){
    t.timer-=dt;
    if(t.timer>0)continue;
    let td=TOWER_TYPES[t.type];
    let nearest=null,nd=Infinity;
    for(let e of enemies){
      if(!e.alive||!e.spawned)continue;
      let d=Math.hypot(e.x-t.x,e.y-t.y);
      if(d<t.range*(1+t.level*0.1)&&d<nd){nd=d;nearest=e}
    }
    if(nearest){
      t.timer=t.rate/(1+t.level*0.15);
      let a=Math.atan2(nearest.y-t.y,nearest.x-t.x);
      projectiles.push({x:t.x,y:t.y,vx:Math.cos(a)*250,vy:Math.sin(a)*250,
        dmg:t.dmg*(1+t.level*0.3),type:td.type,color:td.color,life:1,r:3});
    }
  }

  // Projectiles
  for(let p of projectiles){
    p.x+=p.vx*dt;p.y+=p.vy*dt;p.life-=dt;
    for(let e of enemies){
      if(!e.alive||!e.spawned)continue;
      if(Math.hypot(p.x-e.x,p.y-e.y)<e.r+p.r){
        e.hp-=p.dmg;p.life=0;
        if(p.type==='splash'){
          for(let e2 of enemies){if(e2!==e&&e2.alive&&Math.hypot(e2.x-p.x,e2.y-p.y)<40)e2.hp-=p.dmg*0.5}
          spawnParts(p.x,p.y,p.color,5);
        }
        if(p.type==='slow')e.slow=2;
        if(p.type==='poison')e.poison=3;
        if(p.type==='chain'){
          let targets=[e];
          for(let c=0;c<2;c++){
            let last=targets[targets.length-1],bn=null,bd=Infinity;
            for(let e2 of enemies){if(targets.includes(e2)||!e2.alive)continue;let d=Math.hypot(e2.x-last.x,e2.y-last.y);if(d<80&&d<bd){bd=d;bn=e2}}
            if(bn){targets.push(bn);bn.hp-=p.dmg*0.6}
          }
        }
        if(e.hp<=0){e.alive=false;gold+=e.gold;score+=e.gold;spawnParts(e.x,e.y,e.color,4)}
        break;
      }
    }
  }
  projectiles=projectiles.filter(p=>p.life>0);

  // Particles
  for(let p of particles){p.x+=p.vx*dt;p.y+=p.vy*dt;p.life-=dt}
  particles=particles.filter(p=>p.life>0);

  draw();
}

function spawnParts(x,y,color,n){
  for(let i=0;i<n;i++){
    let a=Math.random()*Math.PI*2;
    particles.push({x,y,vx:Math.cos(a)*80,vy:Math.sin(a)*80,life:0.4,color,r:3});
  }
}

function draw(){
  ctx.fillStyle='#2d5a1e';ctx.fillRect(0,0,W,H);

  if(state==='menu'){
    ctx.fillStyle='#fff';ctx.font='bold 48px sans-serif';ctx.textAlign='center';
    ctx.fillText('ÌÉÄÏõå ÎîîÌéúÏä§',W/2,300);
    ctx.font='24px sans-serif';ctx.fillText('üè∞ SÏûê Í≤ΩÎ°ú ÌÉÄÏõå Î∞∞Ïπò',W/2,360);
    ctx.fillStyle='#4a8';ctx.fillRect(170,450,200,60);
    ctx.fillStyle='#fff';ctx.font='bold 28px sans-serif';ctx.fillText('ÏãúÏûë',W/2,490);
    return;
  }
  if(state==='gameover'){
    ctx.fillStyle='#fff';ctx.font='bold 40px sans-serif';ctx.textAlign='center';
    ctx.fillText('Í≤åÏûÑ Ïò§Î≤Ñ',W/2,350);
    ctx.font='24px sans-serif';ctx.fillText('Wave '+wave+' | Score '+score,W/2,420);
    ctx.fillStyle='#4a8';ctx.fillRect(170,480,200,60);
    ctx.fillStyle='#fff';ctx.font='bold 24px sans-serif';ctx.fillText('Îã§ÏãúÌïòÍ∏∞',W/2,518);
    return;
  }
  if(state==='victory'){
    ctx.fillStyle='#ffd700';ctx.font='bold 44px sans-serif';ctx.textAlign='center';
    ctx.fillText('ÏäπÎ¶¨!',W/2,350);
    ctx.fillStyle='#fff';ctx.font='24px sans-serif';ctx.fillText('30 Ïõ®Ïù¥Î∏å ÌÅ¥Î¶¨Ïñ¥! Score '+score,W/2,420);
    ctx.fillStyle='#4a8';ctx.fillRect(170,480,200,60);
    ctx.fillStyle='#fff';ctx.font='bold 24px sans-serif';ctx.fillText('Îã§ÏãúÌïòÍ∏∞',W/2,518);
    return;
  }

  // HUD top
  ctx.fillStyle='#1a1a2e';ctx.fillRect(0,0,W,MAP_Y-5);
  ctx.fillStyle='#fff';ctx.font='bold 16px sans-serif';ctx.textAlign='left';
  ctx.fillText('üí∞'+gold,15,30);ctx.fillText('‚ù§Ô∏è'+lives,15,50);
  ctx.textAlign='center';ctx.fillText('Wave '+wave+'/'+maxWave,W/2,30);
  ctx.textAlign='right';ctx.fillText('Score '+score,W-15,30);

  // Grid
  for(let r=0;r<ROWS;r++){
    for(let cl=0;cl<COLS;cl++){
      let x=MAP_X+cl*TILE,y=MAP_Y+r*TILE;
      let key=r*COLS+cl;
      ctx.fillStyle=pathTiles.has(key)?'#8b7355':'#3a7a2a';
      ctx.fillRect(x,y,TILE-1,TILE-1);
    }
  }

  // Towers
  for(let t of towers){
    let td=TOWER_TYPES[t.type];
    // Range circle when selected
    if(selectedTower===t.type){
      ctx.globalAlpha=0.1;ctx.fillStyle=td.color;
      ctx.beginPath();ctx.arc(t.x,t.y,t.range*(1+t.level*0.1),0,Math.PI*2);ctx.fill();
      ctx.globalAlpha=1;
    }
    ctx.fillStyle=td.color;
    ctx.fillRect(t.x-TILE/3,t.y-TILE/3,TILE*2/3,TILE*2/3);
    ctx.fillStyle='#fff';ctx.font='10px sans-serif';ctx.textAlign='center';
    ctx.fillText(td.name,t.x,t.y+4);
    if(t.level>1){ctx.fillStyle='#ff0';ctx.font='8px sans-serif';ctx.fillText('Lv'+t.level,t.x,t.y+14)}
  }

  // Enemies
  for(let e of enemies){
    if(!e.alive||!e.spawned)continue;
    ctx.fillStyle=e.slow>0?'#88f':e.color;
    ctx.beginPath();ctx.arc(e.x,e.y,e.r,0,Math.PI*2);ctx.fill();
    if(e.poison>0){ctx.strokeStyle='#0f0';ctx.lineWidth=2;ctx.stroke()}
    ctx.fillStyle='#300';ctx.fillRect(e.x-e.r,e.y-e.r-6,e.r*2,3);
    ctx.fillStyle='#f00';ctx.fillRect(e.x-e.r,e.y-e.r-6,e.r*2*(e.hp/e.maxHp),3);
  }

  // Projectiles
  for(let p of projectiles){ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(p.x,p.y,p.r,0,Math.PI*2);ctx.fill()}

  // Particles
  for(let p of particles){ctx.globalAlpha=p.life*2;ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(p.x,p.y,p.r,0,Math.PI*2);ctx.fill()}
  ctx.globalAlpha=1;

  // Bottom panel
  ctx.fillStyle='#1a1a2e';ctx.fillRect(0,PANEL_Y,W,H-PANEL_Y);
  for(let i=0;i<5;i++){
    let td=TOWER_TYPES[i];
    let x=10+i*105,y=PANEL_Y+5;
    ctx.fillStyle=selectedTower===i?'#445':'#223';
    ctx.fillRect(x,y,100,55);
    ctx.strokeStyle=selectedTower===i?'#8af':'#555';ctx.lineWidth=2;ctx.strokeRect(x,y,100,55);
    ctx.fillStyle=td.color;ctx.fillRect(x+5,y+5,25,25);
    ctx.fillStyle=gold>=td.cost?'#fff':'#666';ctx.font='bold 12px sans-serif';ctx.textAlign='left';
    ctx.fillText(td.name,x+35,y+18);
    ctx.fillStyle=gold>=td.cost?'#ff0':'#633';ctx.font='11px sans-serif';
    ctx.fillText(td.cost+'G',x+35,y+35);
  }

  // Wave button
  ctx.fillStyle=waveActive?'#444':'#4a8';
  ctx.fillRect(W-120,PANEL_Y+65,110,35);
  ctx.fillStyle='#fff';ctx.font='bold 14px sans-serif';ctx.textAlign='center';
  ctx.fillText(waveActive?'ÏßÑÌñâÏ§ë...':'Îã§Ïùå Ïõ®Ïù¥Î∏å',W-65,PANEL_Y+88);

  // Auto toggle
  ctx.fillStyle=autoWave?'#a84':'#444';
  ctx.fillRect(W-120,PANEL_Y+35,110,28);
  ctx.fillStyle='#fff';ctx.font='12px sans-serif';
  ctx.fillText('ÏûêÎèô: '+(autoWave?'ON':'OFF'),W-65,PANEL_Y+54);
}

requestAnimationFrame(update);
</script>
</body></html>
